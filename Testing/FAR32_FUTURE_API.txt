-- Adicionar/modificar estas funções no main.lua

-- Função para escrever dados na memória
function vm.fs_write(addr, data)
    for i = 1, #data do
        vm.mem[addr + i - 1] = data:byte(i)
    end
end

-- Função para atualizar a FAT
function vm.fs_update_fat()
    -- Construir a tabela FAT
    local fat_data = ""
    for i = 1, #vm.filesystem.chunk_map do
        fat_data = fat_data .. (vm.filesystem.chunk_map[i] and "\x01" or "\x00")
    end
    
    -- Escrever FAT no início do sistema de arquivos
    local fat_start = vm.FS_START + 4  -- Após a assinatura 'FS20'
    vm.fs_write(fat_start, fat_data)
    
    -- Escrever número total de chunks
    local total_chunks = #vm.filesystem.chunk_map
    vm.mem[fat_start + #fat_data] = bit32.band(total_chunks, 0xFF)
    vm.mem[fat_start + #fat_data + 1] = bit32.rshift(total_chunks, 8)
end

-- Função auxiliar para escrever entradas de diretório
function vm.fs_update_dir_entries()
    local dir_start = vm.FS_START + 4 + math.ceil(#vm.filesystem.chunk_map / 8) + 2
    local entries = ""
    
    for name, entry in pairs(vm.filesystem.entries) do
        local entry_data = string.pack("<Bc12I3I2",
            entry.type,
            name:sub(1,12),
            entry.size,
            entry.chunks[1]
        )
        entries = entries .. entry_data
    end
    
    vm.fs_write(dir_start, entries)
end

-- Função completa de criação de arquivos revisada
function vm.fs_create(name, ftype, data)
    -- Verificar nome único
    if vm.filesystem.entries[name] then
        return false, "file_exists"
    end
    
    -- Calcular chunks necessários
    local chunks_needed = math.ceil(#data / vm.CHUNK_SIZE)
    local chunks = vm.fs_allocate(chunks_needed)
    if not chunks then return false, "out_of_space" end
    
    -- Criar entrada
    local entry = {
        name = name,
        type = ftype,
        chunks = chunks,
        size = #data,
        timestamp = os.time()
    }
    
    -- Escrever dados
    local write_ptr = vm.FS_START + (chunks[1] - 1) * vm.CHUNK_SIZE
    vm.fs_write(write_ptr, data)
    
    -- Atualizar estruturas
    vm.filesystem.entries[name] = entry
    vm.fs_update_fat()
    vm.fs_update_dir_entries()
    
    return true
end

-- Função de leitura revisada
function vm.fs_read(name)
    local entry = vm.filesystem.entries[name]
    if not entry then return nil end
    
    local data = ""
    for _, chunk in ipairs(entry.chunks) do
        local chunk_start = vm.FS_START + (chunk - 1) * vm.CHUNK_SIZE
        local chunk_end = chunk_start + vm.CHUNK_SIZE - 1
        for addr = chunk_start, math.min(chunk_end, chunk_start + entry.size - 1) do
            data = data .. string.char(vm.mem[addr])
        end
    end
    
    return {
        type = entry.type,
        data = data:sub(1, entry.size),
        size = entry.size,
        created = entry.timestamp
    }
end

-- Função de deleção
function vm.fs_delete(name)
    local entry = vm.filesystem.entries[name]
    if not entry then return false end
    
    -- Liberar chunks
    for _, chunk in ipairs(entry.chunks) do
        vm.filesystem.chunk_map[chunk] = false
    end
    
    -- Remover entrada
    vm.filesystem.entries[name] = nil
    
    -- Atualizar estruturas
    vm.fs_update_fat()
    vm.fs_update_dir_entries()
    
    return true
end