local bit32 = require("libs/bit32")

-- Configuração da memória
vm.mem_size = 0x20000  -- 128KB total (64KB original + 64KB para arquivos)
vm.CARTRIDGE_START = 0x0000    -- 64KB para cartuchos (0x0000-0xFFFF)
vm.FS_START       = 0x10000    -- 64KB para arquivos (0x10000-0x1FFFF)
vm.FS_HEADER_SIZE = 0x1000     -- 4KB para metadados

-- Tipos de arquivo atualizados
vm.FILE_TYPES = {
    TXT = 0x01,
    LUA = 0x02,
    PNG = 0x03,
    WAV = 0x04,
    F88 = 0x88  -- Tipo especial para cartuchos
}

-- Inicialização da memória
function vm.init()
    vm.mem = {}
    for i = 0, vm.mem_size - 1 do
        vm.mem[i] = 0
    end
    
    -- Inicializar sistema de arquivos
    vm.fs_init()
    
    -- ... (resto da inicialização original)
end

-- Sistema de arquivos na nova região de memória
function vm.fs_init()
    -- Cabeçalho estendido
    vm:fs_write(vm.FS_START, "FSCPv2", 6)  -- Magic number
    vm:fs_write(vm.FS_START + 6, 0x0000)   -- Número de arquivos
    vm:fs_write(vm.FS_START + 8, 0x1000)   -- Endereço livre inicial
    vm:fs_write(vm.FS_START + 10, 0x00)    -- Flags
    
    -- Tabela de arquivos
    vm.fs_files = {}
    vm.fs_free_space = vm.FS_START + vm.FS_HEADER_SIZE
end

-- Funções de acesso à memória modificadas
function vm.peek(addr)
    if addr >= vm.CARTRIDGE_START and addr <= vm.CARTRIDGE_START + 0xFFFF then
        return vm.mem[addr] or 0
    end
    -- Acesso normal para outras áreas
    return vm.mem[addr] or 0
end

function vm.poke(addr, value)
    value = bit32.band(value, 0xFF)
    
    -- Bloquear escrita na área do cartucho
    if addr >= vm.CARTRIDGE_START and addr <= vm.CARTRIDGE_START + 0xFFFF then
        return  -- Memória do cartucho é read-only
    end
    
    -- Gerenciar escrita na área de arquivos
    if addr >= vm.FS_START then
        vm:fs_handle_write(addr, value)
    else
        vm.mem[addr] = value
    end
end

-- Sistema de arquivos aprimorado
function vm:fs_handle_write(addr, value)
    -- Implementação do sistema de arquivos com alocação FAT-like
    local function get_fat_entry(entry)
        local fat_start = vm.FS_START + 0x100
        return vm:fs_read(fat_start + (entry * 4), 4)
    end
    
    local function set_fat_entry(entry, value)
        local fat_start = vm.FS_START + 0x100
        vm:fs_write(fat_start + (entry * 4), value, 4)
    end

    -- ... (implementação completa do sistema de arquivos com FAT)
end

-- Sistema de cartuchos atualizado
function vm.load_cartridge(data)
    -- Verificar assinatura
    if data:sub(1,4) ~= "F88\x1A" then
        error("Formato de cartucho inválido")
    end
    
    -- Carregar para a área de cartuchos
    for i = 1, math.min(#data, 0x10000) do
        vm.mem[i-1] = data:byte(i)
    end
    
    -- Mapear estrutura do cartucho
    local header = {
        version     = data:byte(5),
        entry_point = vm:fs_read16(6),
        crc         = vm:fs_read32(8),
        flags       = vm:fs_read16(12),
        name        = data:sub(14, 30),
        author      = data:sub(31, 47)
    }
    
    -- Executar ponto de entrada
    local entry = vm.peek(header.entry_point)
    if entry == 0xEA then  -- OPCODE NES (emulação básica)
        vm:emulate_nes_cartridge(header)
    else
        local chunk = load(data:sub(65), "cartridge", "t", vm.expose_api())
        if chunk then pcall(chunk) end
    end
end

-- Funções auxiliares para o sistema de arquivos
function vm:fs_write(addr, data, size)
    for i = 0, size - 1 do
        vm.mem[addr + i] = bit32.band(data, 0xFF)
        data = bit32.rshift(data, 8)
    end
end

function vm:fs_read(addr, size)
    local value = 0
    for i = size - 1, 0, -1 do
        value = bit32.lshift(value, 8) + vm.peek(addr + i)
    end
    return value
end

-- API para desenvolvedores de cartuchos
function vm.expose_cartridge_api()
    local api = vm.expose_api()
    
    api.fs = {
        open = function(filename, mode)
            -- Implementação do sistema de arquivos do cartucho
        end,
        list = function()
            -- Listar arquivos no cartucho
        end,
        load = function(filename)
            -- Carregar recurso do cartucho
        end
    }
    
    api.mem = {
        map = function(start, size)
            -- Mapear região de memória
            return {
                read = function(offset)
                    return vm.peek(start + offset)
                end,
                write = function(offset, value)
                    vm.poke(start + offset, value)
                end
            }
        end
    }
    
    return api
end

-- Controle de cartuchos
local cartridges = {}
local current_cart = 0

function love.keypressed(key)
    if key == "tab" then
        current_cart = (current_cart + 1) % #cartridges
        vm.load_cartridge(cartridges[current_cart + 1])
    end
end

-- Função para carregar cartuchos da pasta /cartridges
function love.load()
    local files = love.filesystem.getDirectoryItems("cartridges")
    for _, file in ipairs(files) do
        if file:match("%.F88$") then
            local data = love.filesystem.read("cartridges/" .. file)
            table.insert(cartridges, data)
        end
    end
    
    if #cartridges > 0 then
        vm.load_cartridge(cartridges[1])
    end
end